<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Grid-based Color Fluid Mixer (JS)</title>
  <style>
    /* Body background is a soft gray for the entire page */
    body { 
      margin:0; 
      font-family: system-ui, -apple-system, 'Segoe UI', Roboto, sans-serif; 
      background:#f0f0f0; 
      color:#222; 
      display:flex; 
      height:100vh; 
    }
    #ui { 
      width:320px; 
      padding:16px; 
      box-sizing:border-box; 
      background:rgba(255,255,255,0.8); 
      border-right:1px solid rgba(0,0,0,0.1); 
    }
    #canvasWrap { 
      flex:1; 
      display:flex; 
      align-items:center; 
      justify-content:center; 
    }
    /* The fluid simulation canvas background is set to pure white */
    canvas { 
      background:#ffffff; 
      image-rendering:pixelated; 
      border:1px solid #ccc; 
    }
    label { 
      display:block; 
      margin:8px 0 4px; 
      font-size:13px; 
      color:#222; 
    }
    input[type=range] { width:100%; }
    button { 
      margin-right:8px; 
      margin-top:8px; 
      padding:8px 10px; 
      border:1px solid rgba(0,0,0,0.1); 
      border-radius:6px; 
      cursor:pointer 
    }
    #paintRed { background:#f55; color:#000; }
    #paintGreen { background:#5f5; color:#000; }
    #paintBlue { background:#55f; color:#000; }
    #modeVelocity, #modeObstacle, #clearObstacles, #reset { 
      background:#ddd; 
      color:#222;
    }
    .row { display:flex; gap:8px; align-items:center }
    .small { font-size:12px; color:#555 }
    .hint { font-size:12px; color:#588; margin-top:8px }
  </style>
</head>
<body>
  <div id="ui">
    <h2>Color Fluid Mixer ðŸŽ¨</h2>

    <label>Paint Mode: <span id="colorModeLabel">RED</span></label>
    <div class="row">
      <button id="paintRed">Red</button>
      <button id="paintGreen">Green</button>
      <button id="paintBlue">Blue</button>
    </div>
    <div class="row">
      <button id="modeVelocity">Add Velocity</button>
      <button id="modeObstacle">Toggle Obstacles</button>
    </div>
    <div class="row">
      <button id="clearObstacles">Clear Obstacles</button>
      <button id="reset">Reset Sim</button>
    </div>

    <label>Grid size: <span id="gridSizeLabel">200</span></label>
    <input id="gridSize" type="range" min="32" max="200" value="200" step="1">

    <label>Viscosity: <span id="viscLabel">0.0001</span></label>
    <input id="visc" type="range" min="0" max="0.1" step="0.0001" value="0.0001">

    <label>Diffusion: <span id="diffLabel">0.00001</span></label>
    <input id="diff" type="range" min="0" max="0.01" step="0.00001" value="0.00001">

    <label>Force scale: <span id="forceLabel">5000</span></label>
    <input id="force" type="range" min="10" max="10000" step="10" value="5000">

    <label>Source amount: <span id="sourceLabel">1000</span></label>
    <input id="source" type="range" min="1" max="1000" step="1" value="1000">

    <label>Display: </label>
    <div class="row">
      <label style="display:inline-flex;align-items:center"><input id="showVelocity" type="checkbox"> <span class="small">Velocity</span></label>
      <label style="display:inline-flex;align-items:center"><input id="showDensity" type="checkbox" checked> <span class="small">Color Mix</span></label>
      <label style="display:inline-flex;align-items:center"><input id="showObstacles" type="checkbox" checked> <span class="small">Obstacles</span></label>
    </div>

    <p class="hint">Click to paint your chosen color. Drag to also add velocity and stir the fluid!</p>
    <p class="hint small">This uses a stable fluid solver, applied independently to R, G, and B color channels for mixing.</p>
  </div>
  <div id="canvasWrap">
    <canvas id="c"></canvas>
  </div>

<script>
/* Stable fluid implementation (2D grid). Adapted for color mixing. */
// Utility helpers
function idx(x,y,N){ x = Math.max(0, Math.min(N-1, x)); y = Math.max(0, Math.min(N-1, y)); return x + y * N; }

class Fluid {
  constructor(N, dt, diff, visc){
    this.N = N; this.dt = dt; this.diff = diff; this.visc = visc;
    const size = N*N;
    
    // Density/temp arrays split into R, G, B components
    this.r = new Float32Array(size); // Red density
    this.g = new Float32Array(size); // Green density
    this.b = new Float32Array(size); // Blue density
    this.r0 = new Float32Array(size); // Temp R
    this.g0 = new Float32Array(size); // Temp G
    this.b0 = new Float32Array(size); // Temp B

    this.Vx = new Float32Array(size);
    this.Vy = new Float32Array(size);
    this.Vx0 = new Float32Array(size);
    this.Vy0 = new Float32Array(size);

    this.solid = new Uint8Array(size); // obstacle map, 1 = solid
  }

  addColor(x, y, rAmount, gAmount, bAmount){
    const id = idx(x,y,this.N);
    if(!this.solid[id]){
      this.r[id] += rAmount;
      this.g[id] += gAmount;
      this.b[id] += bAmount;
    }
  }

  addVelocity(x,y,amountX,amountY){
    const id = idx(x,y,this.N);
    if(!this.solid[id]){ this.Vx[id] += amountX; this.Vy[id] += amountY; }
  }

  step(){
    const N = this.N, dt = this.dt;
    
    // Velocity Step: same as before
    this.diffuse(1, this.Vx0, this.Vx, this.visc, dt);
    this.diffuse(2, this.Vy0, this.Vy, this.visc, dt);
    this.project(this.Vx0, this.Vy0, this.Vx, this.Vy);
    this.advect(1, this.Vx, this.Vx0, this.Vx0, this.Vy0, dt);
    this.advect(2, this.Vy, this.Vy0, this.Vx0, this.Vy0, dt);
    this.project(this.Vx, this.Vy, this.Vx0, this.Vy0);

    // Density Step: now for R, G, and B components
    this.diffuse(0, this.r0, this.r, this.diff, dt);
    this.advect(0, this.r, this.r0, this.Vx, this.Vy, dt);
    
    this.diffuse(0, this.g0, this.g, this.diff, dt);
    this.advect(0, this.g, this.g0, this.Vx, this.Vy, dt);
    
    this.diffuse(0, this.b0, this.b, this.diff, dt);
    this.advect(0, this.b, this.b0, this.Vx, this.Vy, dt);

    // enforce solids: zero velocity and density into solids
    for(let i=0;i<N*N;i++){
      if(this.solid[i]){ 
        this.Vx[i]=0; this.Vy[i]=0; 
        this.r[i]=0; this.g[i]=0; this.b[i]=0;
      }
    }
  }

  // linear solver: diffuse quantities (generic for R, G, B)
  diffuse(b, x, x0, diff, dt){
    const N = this.N; const a = dt * diff * (N-2) * (N-2);
    this.lin_solve(b, x, x0, a, 1 + 4*a);
  }

  lin_solve(b, x, x0, a, c){
    const N = this.N;
    // Gauss-Seidel iterations
    for(let k=0;k<20;k++){
      for(let j=1;j<N-1;j++){
        for(let i=1;i<N-1;i++){
          const id = i + j*N;
          x[id] = (x0[id] + a*(x[id-1] + x[id+1] + x[id-N] + x[id+N]))/c;
        }
      }
      this.set_bnd(b,x);
    }
  }

  project(velocX, velocY, p, div){
    const N = this.N;
    const h = 1.0 / N;
    for(let j=1;j<N-1;j++){
      for(let i=1;i<N-1;i++){
        const id = i + j*N;
        div[id] = -0.5*(velocX[id+1]-velocX[id-1] + velocY[id+N]-velocY[id-N])/N;
        p[id] = 0;
      }
    }
    this.set_bnd(0,div); this.set_bnd(0,p);
    this.lin_solve(0, p, div, 1, 4);
    for(let j=1;j<N-1;j++){
      for(let i=1;i<N-1;i++){
        const id = i + j*N;
        velocX[id] -= 0.5*(p[id+1]-p[id-1])*N;
        velocY[id] -= 0.5*(p[id+N]-p[id-N])*N;
      }
    }
    this.set_bnd(1,velocX); this.set_bnd(2,velocY);
  }

  advect(b, d, d0, velocX, velocY, dt){
    const N = this.N; const dt0 = dt * (N-2);
    for(let j=1;j<N-1;j++){
      for(let i=1;i<N-1;i++){
        let x = i - dt0 * velocX[i + j*N];
        let y = j - dt0 * velocY[i + j*N];
        if(x<0.5) x=0.5; if(x>N-1.5) x=N-1.5;
        if(y<0.5) y=0.5; if(y>N-1.5) y=N-1.5;
        const i0 = Math.floor(x); const i1 = i0+1;
        const j0 = Math.floor(y); const j1 = j0+1;
        const s1 = x - i0; const s0 = 1 - s1;
        const t1 = y - j0; const t0 = 1 - t1;
        const id = i + j*N;
        const id00 = i0 + j0*N; const id01 = i0 + j1*N; const id10 = i1 + j0*N; const id11 = i1 + j1*N;
        d[id] = s0*(t0*d0[id00] + t1*d0[id01]) + s1*(t0*d0[id10] + t1*d0[id11]);
      }
    }
    this.set_bnd(b,d);
  }

  set_bnd(b, x){
    const N = this.N;
    for(let i=1;i<N-1;i++){
      x[i] = (b===1? -x[i+N] : x[i+N]); // top
      x[i + (N-1)*N] = (b===1? -x[i + (N-2)*N] : x[i + (N-2)*N]); // bottom
      x[i*N] = (b===2? -x[1 + i*N] : x[1 + i*N]); // left
      x[(N-1) + i*N] = (b===2? -x[(N-2) + i*N] : x[(N-2) + i*N]); // right
    }
    // corners
    x[0] = 0.5*(x[1] + x[N]);
    x[N-1] = 0.5*(x[N-2] + x[2*N-1]);
    x[(N-1)*N] = 0.5*(x[(N-1)*N + 1] + x[(N-2)*N]);
    x[N*N-1] = 0.5*(x[N*N-2] + x[N*(N-1)-1]);

    // enforce solids boundary
    for(let j=1;j<N-1;j++){
      for(let i=1;i<N-1;i++){
        const id = i + j*N;
        if(this.solid[id]){
          x[id]=0;
        }
      }
    }
  }
}

// --- UI and rendering ---
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let N = parseInt(document.getElementById('gridSize').value);
let sim = new Fluid(N, 0.016, parseFloat(document.getElementById('diff').value), parseFloat(document.getElementById('visc').value));

function resizeCanvas(){
  const maxW = window.innerWidth - 320 - 40; // account UI width and margins
  const maxH = window.innerHeight - 40;
  const size = Math.min(maxW, maxH);
  canvas.width = size; canvas.height = size;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

let mouse = {x:0,y:0,px:0,py:0,down:false};
let mode = 'red'; // Default mode is now 'red'
const colorModeLabel = document.getElementById('colorModeLabel');

function screenToGrid(sx, sy){
  const rect = canvas.getBoundingClientRect();
  const x = Math.floor((sx - rect.left) / rect.width * sim.N);
  const y = Math.floor((sy - rect.top) / rect.height * sim.N);
  return {x: x, y: y};
}

canvas.addEventListener('pointerdown', (e)=>{
  canvas.setPointerCapture(e.pointerId);
  mouse.down = true;
  const p = screenToGrid(e.clientX, e.clientY);
  mouse.x = p.x; mouse.y = p.y; mouse.px=p.x; mouse.py=p.y;
  if(mode==='obstacle'){
    const id = idx(p.x,p.y,sim.N);
    sim.solid[id] = sim.solid[id]?0:1;
  }
});

canvas.addEventListener('pointermove', (e)=>{
  const p = screenToGrid(e.clientX, e.clientY);
  if(mouse.down){
    const dx = p.x - mouse.px; const dy = p.y - mouse.py;
    
    if(['red', 'green', 'blue', 'velocity'].includes(mode)){ 
      const steps = Math.max(Math.abs(dx), Math.abs(dy),1);
      const sourceAmount = parseFloat(document.getElementById('source').value);
      
      for(let i=0;i<steps;i++){
        const sx = Math.round(mouse.px + dx*(i/steps));
        const sy = Math.round(mouse.py + dy*(i/steps));
        
        // Add color based on the selected mode
        if(mode==='red') sim.addColor(sx, sy, sourceAmount, 0, 0);
        else if(mode==='green') sim.addColor(sx, sy, 0, sourceAmount, 0);
        else if(mode==='blue') sim.addColor(sx, sy, 0, 0, sourceAmount);
        
        // Velocity (add forces for mixing/stirring)
        const force = parseFloat(document.getElementById('force').value);
        sim.addVelocity(sx,sy, (p.x-mouse.px)*force*0.0001, (p.y-mouse.py)*force*0.0001 );
      }
    } else if(mode==='obstacle'){
      const id = idx(p.x,p.y,sim.N);
      sim.solid[id] = sim.solid[id]?0:1;
    }
    mouse.px = p.x; mouse.py = p.y;
  }
});

canvas.addEventListener('pointerup', (e)=>{ mouse.down=false; canvas.releasePointerCapture(e.pointerId); });

// UI hooks
document.getElementById('paintRed').onclick = ()=>{ mode='red'; colorModeLabel.textContent = 'RED'; }
document.getElementById('paintGreen').onclick = ()=>{ mode='green'; colorModeLabel.textContent = 'GREEN'; }
document.getElementById('paintBlue').onclick = ()=>{ mode='blue'; colorModeLabel.textContent = 'BLUE'; }
document.getElementById('modeVelocity').onclick = ()=>{ mode='velocity'; colorModeLabel.textContent = 'N/A (Velocity)'; }
document.getElementById('modeObstacle').onclick = ()=>{ mode='obstacle'; colorModeLabel.textContent = 'N/A (Obstacle)'; }

document.getElementById('clearObstacles').onclick = ()=>{ sim.solid.fill(0); }
document.getElementById('reset').onclick = ()=>{ sim = new Fluid(sim.N, sim.dt, sim.diff, sim.visc); }

const gridSizeInput = document.getElementById('gridSize');
const gridSizeLabel = document.getElementById('gridSizeLabel');
gridSizeInput.oninput = ()=>{
  gridSizeLabel.textContent = gridSizeInput.value;
};
gridSizeInput.onchange = ()=>{
  N = parseInt(gridSizeInput.value);
  sim = new Fluid(N, 0.016, parseFloat(document.getElementById('diff').value), parseFloat(document.getElementById('visc').value));
}

const viscInput = document.getElementById('visc'); const viscLabel = document.getElementById('viscLabel');
viscInput.oninput = ()=>{ viscLabel.textContent = viscInput.value; sim.visc = parseFloat(viscInput.value); }

const diffInput = document.getElementById('diff'); const diffLabel = document.getElementById('diffLabel');
diffInput.oninput = ()=>{ diffLabel.textContent = diffInput.value; sim.diff = parseFloat(diffInput.value); }

const forceInput = document.getElementById('force'); const forceLabel = document.getElementById('forceLabel');
forceInput.oninput = ()=>{ forceLabel.textContent = forceInput.value; }

const sourceInput = document.getElementById('source'); const sourceLabel = document.getElementById('sourceLabel');
sourceInput.oninput = ()=>{ sourceLabel.textContent = sourceInput.value; }

const showVelocity = document.getElementById('showVelocity');
const showDensity = document.getElementById('showDensity');
const showObstacles = document.getElementById('showObstacles');

// rendering
function draw(){
  const N = sim.N; const w = canvas.width; const h = canvas.height; const cellW = w / N; const cellH = h / N;
  ctx.clearRect(0,0,w,h);
  const img = ctx.createImageData(w,h);
  
  // draw density as color mix
  if(showDensity.checked){
    // for each grid cell, fill its block of pixels
    for(let j=0;j<N;j++){
      for(let i=0;i<N;i++){
        const id = i + j*N;
        
        // Read R, G, B densities and clamp/scale them to 0-255 range
        const scale = 0.2; // Adjust for brightness/saturation
        const maxColorValue = 255;
        const r = Math.min(maxColorValue, sim.r[id] * scale);
        const g = Math.min(maxColorValue, sim.g[id] * scale);
        const b = Math.min(maxColorValue, sim.b[id] * scale);

        // fill cell rectangle
        const sx = Math.floor(i*cellW), sy = Math.floor(j*cellH);
        const ex = Math.ceil((i+1)*cellW), ey = Math.ceil((j+1)*cellH);
        for(let y=sy;y<ey;y++){
          for(let x=sx;x<ex;x++){
            const p = (x + y*w) * 4;
            img.data[p] = r;     // Red
            img.data[p+1] = g;   // Green
            img.data[p+2] = b;   // Blue
            img.data[p+3] = 255; // Alpha
          }
        }
      }
    }
  }
  
  // draw obstacles overlay
  if(showObstacles.checked){
    for(let j=0;j<N;j++){
      for(let i=0;i<N;i++){
        const id = i + j*N;
        if(sim.solid[id]){
          const sx = Math.floor(i*cellW), sy = Math.floor(j*cellH);
          const ex = Math.ceil((i+1)*cellW), ey = Math.ceil((j+1)*cellH);
          for(let y=sy;y<ey;y++){
            for(let x=sx;x<ex;x++){
              const p = (x + y*w) * 4;
              img.data[p]=180; img.data[p+1]=180; img.data[p+2]=180; img.data[p+3]=255; /* Light gray obstacle */
            }
          }
        }
      }
    }
  }
  ctx.putImageData(img,0,0);

  // draw velocity vectors
  if(showVelocity.checked){
    ctx.save();
    ctx.strokeStyle = 'rgba(0,0,0,0.6)'; /* Darker vectors for white background */
    ctx.lineWidth = 1;
    const step = Math.max(2, Math.floor(N/24));
    for(let j=1;j<N-1;j+=step){
      for(let i=1;i<N-1;i+=step){
        const id = i + j*N;
        if(sim.solid[id]) continue;
        const vx = sim.Vx[id]; const vy = sim.Vy[id];
        const cx = (i+0.5)*cellW; const cy = (j+0.5)*cellH;
        ctx.beginPath(); ctx.moveTo(cx,cy);
        ctx.lineTo(cx + vx*cellW*4, cy + vy*cellH*4); ctx.stroke();
      }
    }
    ctx.restore();
  }
}

function frame(){
  sim.step();
  draw();
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);
</script>
</body>
</html>
